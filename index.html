<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Time Weaver</title>
    <style>
        body {
            font-family: 'Trebuchet MS', sans-serif;
            background: radial-gradient(circle, #1e1e2f, #343456);
            color: #ffffff;
            text-align: center;
            margin: 0;
            padding: 0;
        }

        h1 {
            margin-top: 20px;
            font-size: 3rem;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.7);
        }

        #threadButton {
            margin: 20px auto;
            padding: 20px 40px;
            font-size: 1.5rem;
            background: linear-gradient(90deg, #6c63ff, #867dfc);
            border: none;
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 8px #4941d6;
            transition: all 0.3s ease;
        }

        #threadButton:active {
            box-shadow: 0 4px #4941d6;
            transform: translateY(4px);
        }

        #threadButton:hover {
            background: linear-gradient(90deg, #867dfc, #6c63ff);
        }

        #resources {
            margin: 20px 0;
            font-size: 1.2rem;
        }

        .upgrade {
            margin: 15px;
            padding: 15px 30px;
            font-size: 1.1rem;
            background: linear-gradient(90deg, #4caf50, #81c784);
            border: none;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 6px #388e3c;
            transition: all 0.3s ease;
        }

        .upgrade:disabled {
            background: #777;
            cursor: not-allowed;
            box-shadow: none;
        }

        .upgrade:hover:not(:disabled) {
            background: linear-gradient(90deg, #81c784, #4caf50);
        }

        .upgrade:active:not(:disabled) {
            box-shadow: 0 3px #388e3c;
            transform: translateY(3px);
        }

        #timeline {
            margin: 20px auto;
            padding: 20px;
            background: #2c2f3a;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            color: #ddd;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.5);
            text-align: left;
        }

        #timeline h2 {
            margin: 0 0 20px;
            font-size: 2rem;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.6);
        }

        .event {
            margin: 10px 0;
            padding: 10px;
            background: linear-gradient(90deg, #607d8b, #78909c);
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1rem;
        }

        .visual-feedback {
            position: absolute;
            pointer-events: none;
            font-size: 1rem;
            color: #ffd700;
            animation: fadeOut 1s ease forwards;
        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px);
            }
        }
    </style>
</head>
<body>
    <h1>Time Weaver</h1>

    <div id="resources">
        <p><strong>Threads:</strong> <span id="threadCount">0</span></p>
        <p><strong>Threads / second:</strong> <span id="threadsPerSecond">0</span></p>
    </div>

    <button id="threadButton">Weave Time Thread</button>

    <div id="upgrades">
        <button class="upgrade" id="loomSpinnerUpgrade" disabled>Buy Loom Spinner (50 threads)</button>
        <!-- Speed Upgrade button -->
        <button class="upgrade" id="speedUpgrade" disabled></button>
        <!-- Efficiency Upgrade button -->
        <button class="upgrade" id="efficiencyUpgrade" disabled></button>
    </div>

    <!-- You can keep these buttons if you also want manual save/load,
         but it's optional once auto save/load is in place -->
    <div>
        <button class="upgrade" id="saveGame">Save Game</button>
    </div>

    <div id="timeline">
        <h2>Timeline</h2>
        <button class="upgrade" id="createEvent" disabled>Weave Event (100 threads)</button>
        <div id="events">
            <!-- Timeline events will appear here -->
        </div>
    </div>

    <script>
        // Core resources
        let threads = 0;

        // Loom Spinner data
        let loomSpinners = 0;
        let loomSpinnerCost = 50;

        // Speed Upgrade
        let speedLevel = 0;
        const speedCosts = [50, 150, 300, 600, 1200];

        // Efficiency Upgrade
        let efficiencyLevel = 0;
        const efficiencyCosts = [100, 200, 400, 800];

        // Cost for weaving an event
        let eventCost = 100;

        // ----- HELPER FUNCTIONS -----
        function getCostDiscountFactor() {
            // 5% discount per level, never below 50%
            const discount = 0.05 * efficiencyLevel;
            return Math.max(1 - discount, 0.5);
        }

        function getProductionMultiplier() {
            // +10% per efficiency level
            return 1 + 0.1 * efficiencyLevel;
        }

        // Dynamic cost for Speed Upgrades
        function getSpeedUpgradeBaseCost() {
            if (speedLevel < speedCosts.length) {
                return speedCosts[speedLevel];
            } else {
                // beyond array => double the last known cost
                let lastCost = speedCosts[speedCosts.length - 1];
                return lastCost * Math.pow(2, speedLevel - speedCosts.length + 1);
            }
        }
        function getSpeedUpgradeCost() {
            return Math.floor(getSpeedUpgradeBaseCost() * getCostDiscountFactor());
        }

        // Dynamic cost for Efficiency Upgrades
        function getEfficiencyUpgradeBaseCost() {
            if (efficiencyLevel < efficiencyCosts.length) {
                return efficiencyCosts[efficiencyLevel];
            } else {
                let lastCost = efficiencyCosts[efficiencyCosts.length - 1];
                return lastCost * Math.pow(2, efficiencyLevel - efficiencyCosts.length + 1);
            }
        }
        function getEfficiencyUpgradeCost() {
            // Efficiency upgrade cost is not discounted by itself
            return getEfficiencyUpgradeBaseCost();
        }

        function getLoomSpinnerCost() {
            return Math.floor(loomSpinnerCost * getCostDiscountFactor());
        }

        function getThreadsPerSecond() {
            // Each Loom Spinner produces 1 base, multiplied by 2^speedLevel, then efficiency bonus
            const spinnerRate = Math.pow(2, speedLevel) * getProductionMultiplier();
            return Math.floor(loomSpinners * spinnerRate);
        }

        // ----- UI UPDATES -----
        function updateUI() {
            document.getElementById('threadCount').textContent = threads;
            document.getElementById('threadsPerSecond').textContent = getThreadsPerSecond();

            // Loom Spinner button
            const spinnerCost = getLoomSpinnerCost();
            const spinnerBtn = document.getElementById('loomSpinnerUpgrade');
            spinnerBtn.textContent = `Buy Loom Spinner (${spinnerCost} threads)`;
            spinnerBtn.disabled = threads < spinnerCost;

            // Speed Upgrade button
            const speedCost = getSpeedUpgradeCost();
            const speedBtn = document.getElementById('speedUpgrade');
            speedBtn.textContent = `Speed Upgrade (Cost: ${speedCost}, Level: ${speedLevel})`;
            speedBtn.disabled = threads < speedCost;

            // Efficiency Upgrade button
            const effCost = getEfficiencyUpgradeCost();
            const effBtn = document.getElementById('efficiencyUpgrade');
            effBtn.textContent = `Efficiency Upgrade (Cost: ${effCost}, Level: ${efficiencyLevel})`;
            effBtn.disabled = threads < effCost;

            // Event creation button
            document.getElementById('createEvent').disabled = threads < eventCost;
        }

        // Visual feedback
        function showVisualFeedback(text, x, y) {
            const feedback = document.createElement('div');
            feedback.classList.add('visual-feedback');
            feedback.style.left = `${x}px`;
            feedback.style.top = `${y}px`;
            feedback.textContent = text;
            document.body.appendChild(feedback);

            setTimeout(() => {
                feedback.remove();
            }, 1000);
        }

        // ----- GAME LOGIC & EVENTS -----
        document.getElementById('threadButton').addEventListener('click', (e) => {
            threads++;
            updateUI();

            // Show the +1 feedback
            const rect = e.target.getBoundingClientRect();
            const x = rect.left + rect.width / 2;
            const y = rect.top;
            showVisualFeedback('+1', x, y);
        });

        document.getElementById('loomSpinnerUpgrade').addEventListener('click', () => {
            const cost = getLoomSpinnerCost();
            if (threads >= cost) {
                threads -= cost;
                loomSpinners++;
                // Increase base cost for the next Loom Spinner
                loomSpinnerCost = Math.floor(loomSpinnerCost * 1.5);
                updateUI();
            }
        });

        document.getElementById('speedUpgrade').addEventListener('click', () => {
            const cost = getSpeedUpgradeCost();
            if (threads >= cost) {
                threads -= cost;
                speedLevel++;
                updateUI();
            }
        });

        document.getElementById('efficiencyUpgrade').addEventListener('click', () => {
            const cost = getEfficiencyUpgradeCost();
            if (threads >= cost) {
                threads -= cost;
                efficiencyLevel++;
                updateUI();
            }
        });

        // Automation for thread production
        setInterval(() => {
            const tps = getThreadsPerSecond();
            if (tps > 0) {
                threads += tps;
                updateUI();

                // Show feedback on the main button
                const button = document.getElementById('threadButton');
                const rect = button.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top;
                showVisualFeedback(`+${tps}`, x, y);
            }
        }, 1000);

        // Create timeline event
        document.getElementById('createEvent').addEventListener('click', () => {
            if (threads >= eventCost) {
                threads -= eventCost;
                const eventDiv = document.createElement('div');
                eventDiv.classList.add('event');
                eventDiv.textContent = `Event ${document.querySelectorAll('.event').length + 1}: A moment in time.`;
                document.getElementById('events').appendChild(eventDiv);
                updateUI();
            }
        });

        // ----- SAVE / LOAD FUNCTIONALITY -----
        function saveGame() {
            const gameState = {
                threads,
                loomSpinners,
                speedLevel,
                efficiencyLevel,
                loomSpinnerCost,
                // We'll store the text from each event so we can rebuild them on load
                events: []
            };

            document.querySelectorAll('.event').forEach(eventDiv => {
                gameState.events.push(eventDiv.textContent);
            });

            localStorage.setItem('timeWeaverSave', JSON.stringify(gameState));
            // Silently save (or optionally console.log / show a small message)
            console.log('Game auto-saved.');
        }

        function loadGame() {
            const savedData = localStorage.getItem('timeWeaverSave');
            if (!savedData) {
                console.log('No saved game found!');
                return;
            }
            try {
                const data = JSON.parse(savedData);
                threads = data.threads || 0;
                loomSpinners = data.loomSpinners || 0;
                speedLevel = data.speedLevel || 0;
                efficiencyLevel = data.efficiencyLevel || 0;
                loomSpinnerCost = data.loomSpinnerCost || 50;

                // Rebuild event list
                const eventsContainer = document.getElementById('events');
                eventsContainer.innerHTML = '';
                if (Array.isArray(data.events)) {
                    data.events.forEach((eventText) => {
                        const eventDiv = document.createElement('div');
                        eventDiv.classList.add('event');
                        eventDiv.textContent = eventText;
                        eventsContainer.appendChild(eventDiv);
                    });
                }

                updateUI();
                console.log('Game auto-loaded successfully!');
            } catch (e) {
                console.error('Error loading save data: ', e);
                alert('Failed to load the game. The save data might be corrupted.');
            }
        }

        // Hook up manual Save/Load buttons (if kept)
        document.getElementById('saveGame').addEventListener('click', saveGame);

        // ----- AUTOMATIC LOAD ON PAGE LOAD -----
        // This will attempt to load the game immediately.
        loadGame();

        // ----- AUTOMATIC SAVE -----
        // Save the game every 10 seconds (adjust as desired)
        setInterval(saveGame, 10000);

        // Initialize UI after load or fresh start
        updateUI();
    </script>
</body>
</html>
